// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Char from "../../node_modules/bs-platform/lib/es6/char.js";
import * as List from "../../node_modules/bs-platform/lib/es6/list.js";
import * as Caml_obj from "../../node_modules/bs-platform/lib/es6/caml_obj.js";
import * as Pervasives from "../../node_modules/bs-platform/lib/es6/pervasives.js";
import * as Caml_string from "../../node_modules/bs-platform/lib/es6/caml_string.js";

function next_char(s, i) {
  if (i < s.length) {
    return Caml_string.get(s, i);
  }
  
}

var letters = /[a-z]/;

function lexer$prime(term, _i, _seen) {
  while(true) {
    var seen = _seen;
    var i = _i;
    console.log(term);
    var x = next_char(term, i);
    if (x === undefined) {
      return {
              hd: /* EOF */0,
              tl: /* [] */0
            };
    }
    if (letters.test(Char.escaped(x))) {
      _seen = seen + Char.escaped(x);
      _i = i + 1 | 0;
      continue ;
    }
    if (seen !== "") {
      return {
              hd: /* ID */{
                _0: seen
              },
              tl: lexer$prime(term, i, "")
            };
    }
    var t;
    if (x >= 47) {
      t = x !== 92 ? /* GARBAGE */5 : /* LAMBDA */1;
    } else if (x >= 40) {
      switch (x - 40 | 0) {
        case 0 :
            t = /* LBRACKET */2;
            break;
        case 1 :
            t = /* RBRACKET */3;
            break;
        case 2 :
        case 3 :
        case 4 :
        case 5 :
            t = /* GARBAGE */5;
            break;
        case 6 :
            t = /* DOT */4;
            break;
        
      }
    } else {
      t = /* GARBAGE */5;
    }
    if (t !== /* GARBAGE */5) {
      return {
              hd: t,
              tl: lexer$prime(term, i + 1 | 0, "")
            };
    }
    _seen = "";
    _i = i + 1 | 0;
    continue ;
  };
}

function lexer(term) {
  return lexer$prime(term, 0, "");
}

function next(token, tokens) {
  if (tokens) {
    return Caml_obj.caml_equal(tokens.hd, token);
  } else {
    return false;
  }
}

function match(token, tokens) {
  if (next(token, tokens)) {
    return List.tl(tokens);
  } else {
    return Pervasives.failwith("error!");
  }
}

function skip(token, tokens) {
  if (tokens && Caml_obj.caml_equal(tokens.hd, token)) {
    return [
            true,
            tokens.tl
          ];
  } else {
    return [
            false,
            tokens
          ];
  }
}

function application(tokens, ctx) {
  return Pervasives.failwith("todo");
}

function term(tokens, ctx) {
  if (!tokens) {
    return application(tokens, ctx);
  }
  var match = tokens.hd;
  if (typeof match === "number" && match === 1) {
    return Pervasives.failwith("todo");
  } else {
    return application(tokens, ctx);
  }
}

function atom(tokens, ctx) {
  return Pervasives.failwith("todo");
}

export {
  next_char ,
  letters ,
  lexer$prime ,
  lexer ,
  next ,
  match ,
  skip ,
  term ,
  application ,
  atom ,
  
}
/* No side effect */
